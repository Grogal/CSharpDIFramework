using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;

using Microsoft.CodeAnalysis;

namespace CSharpDIFramework.SourceGenerators;

internal static class CodeGenerator
{
    private static readonly SymbolDisplayFormat s_fullyQualifiedFormat = SymbolDisplayFormat.FullyQualifiedFormat
                                                                                            .WithGlobalNamespaceStyle(
                                                                                                SymbolDisplayGlobalNamespaceStyle.Included
                                                                                            );

    public static string Generate(ContainerBlueprint blueprint)
    {
        var sb = new StringBuilder();

        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();

        if (!string.IsNullOrEmpty(blueprint.Namespace))
        {
            sb.AppendLine($"namespace {blueprint.Namespace!};");
            sb.AppendLine();
        }

        // Calculate base indentation level based on containing type declarations
        var indentLevel = 0;
        foreach (string? declaration in blueprint.ContainingTypeDeclarations)
        {
            sb.AppendLine($"{new string(' ', indentLevel * 4)}{declaration}");
            sb.AppendLine($"{new string(' ', indentLevel * 4)}{{");
            indentLevel++;
        }

        // Generate the container class with proper indentation
        var baseIndent = new string(' ', indentLevel * 4);
        sb.AppendLine($"{baseIndent}public partial class {blueprint.ContainerName}");
        sb.AppendLine($"{baseIndent}{{");

        List<ResolvedService> singletons = blueprint.Services.Where(s => s.Lifetime == ServiceLifetime.Singleton).ToList();

        GenerateSingletonFields(sb, singletons, indentLevel + 1);
        GenerateConstructor(sb, blueprint.ContainerName, singletons, indentLevel + 1);
        GenerateSingletonFactories(sb, singletons, indentLevel + 1);
        GenerateResolveMethod(sb, blueprint, indentLevel + 1);

        sb.AppendLine($"{baseIndent}}}");

        // Close all containing type declarations
        for (int i = indentLevel - 1; i >= 0; i--)
        {
            sb.AppendLine($"{new string(' ', i * 4)}}}");
        }

        return sb.ToString();
    }

    public static string GenerateDummyFromName(string containerName, INamedTypeSymbol containerSymbol)
    {
        ImmutableArray<string> containingDecls = GraphBuilder.GetContainingTypeDeclarations(containerSymbol);
        string? ns = containerSymbol.ContainingNamespace.IsGlobalNamespace ? null : containerSymbol.ContainingNamespace.ToDisplayString();
        var dummyBlueprint = new ContainerBlueprint(containerSymbol, containerName, ns, ImmutableArray<ResolvedService>.Empty, Location.None, containingDecls);
        return GenerateDummyContainer(dummyBlueprint);
    }

    public static string GenerateDummyContainer(ContainerBlueprint blueprint)
    {
        var sb = new StringBuilder();

        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("// DI Container generation failed due to errors.");
        sb.AppendLine("// This is a dummy implementation. Please see the Error List for details.");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();

        if (!string.IsNullOrEmpty(blueprint.Namespace))
        {
            sb.AppendLine($"namespace {blueprint.Namespace!};");
            sb.AppendLine();
        }

        foreach (string declaration in blueprint.ContainingTypeDeclarations)
        {
            sb.AppendLine(declaration);
            sb.AppendLine("{");
        }

        var indent = new string(' ', blueprint.ContainingTypeDeclarations.Length * 4);
        sb.AppendLine($"{indent}public partial class {blueprint.ContainerName}");
        sb.AppendLine($"{indent}{{");
        sb.AppendLine($"{indent}    private const string ErrorMessage = \"CSharpDIFramework container generation failed. See compile-time errors.\";");
        sb.AppendLine($"{indent}    public T Resolve<T>() => throw new global::System.InvalidOperationException(ErrorMessage);");
        sb.AppendLine($"{indent}}}");

        for (int i = blueprint.ContainingTypeDeclarations.Length - 1; i >= 0; i--)
        {
            sb.AppendLine($"{new string(' ', i * 4)}}}");
        }

        return sb.ToString();
    }

    private static void GenerateSingletonFields(StringBuilder sb, List<ResolvedService> singletons, int indentLevel)
    {
        var indent = new string(' ', indentLevel * 4);
        foreach (ResolvedService s in singletons)
        {
            string serviceType = s.ServiceType.ToDisplayString(s_fullyQualifiedFormat);
            sb.AppendLine($"{indent}private readonly global::System.Lazy<{serviceType}> {GetSingletonFieldName(s.ServiceType)};");
        }

        sb.AppendLine();
    }

    private static void GenerateConstructor(StringBuilder sb, string containerName, List<ResolvedService> singletons, int indentLevel)
    {
        var indent = new string(' ', indentLevel * 4);
        var innerIndent = new string(' ', (indentLevel + 1) * 4);

        sb.AppendLine($"{indent}public {containerName}()");
        sb.AppendLine($"{indent}{{");

        foreach (ResolvedService s in singletons)
        {
            string serviceType = s.ServiceType.ToDisplayString(s_fullyQualifiedFormat);

            sb.AppendLine(
                $"{innerIndent}{GetSingletonFieldName(s.ServiceType)} = new global::System.Lazy<{serviceType}>(() => {GetFactoryMethodName(s.ServiceType)}());"
            );
        }

        sb.AppendLine($"{indent}}}");
        sb.AppendLine();
    }

    private static void GenerateSingletonFactories(StringBuilder sb, List<ResolvedService> singletons, int indentLevel)
    {
        var indent = new string(' ', indentLevel * 4);
        var innerIndent = new string(' ', (indentLevel + 1) * 4);

        foreach (ResolvedService service in singletons)
        {
            string serviceType = service.ServiceType.ToDisplayString(s_fullyQualifiedFormat);
            string implType = service.SourceRegistration.ImplementationType.ToDisplayString(s_fullyQualifiedFormat);

            sb.AppendLine($"{indent}private {serviceType} {GetFactoryMethodName(service.ServiceType)}()");
            sb.AppendLine($"{indent}{{");

            var constructorArgs = new List<string>();
            foreach (ResolvedService? dependency in service.Dependencies)
            {
                string dependencyType = dependency.ServiceType.ToDisplayString(s_fullyQualifiedFormat);
                constructorArgs.Add($"Resolve<{dependencyType}>()");
            }

            sb.AppendLine($"{innerIndent}return new {implType}({string.Join(", ", constructorArgs)});");
            sb.AppendLine($"{indent}}}");
            sb.AppendLine();
        }
    }

    private static void GenerateResolveMethod(StringBuilder sb, ContainerBlueprint blueprint, int indentLevel)
    {
        var indent = new string(' ', indentLevel * 4);
        var innerIndent = new string(' ', (indentLevel + 1) * 4);
        var doubleIndent = new string(' ', (indentLevel + 2) * 4);

        sb.AppendLine($"{indent}public T Resolve<T>()");
        sb.AppendLine($"{indent}{{");

        var isFirst = true;
        foreach (ResolvedService service in blueprint.Services)
        {
            string ifPrefix = isFirst ? "if" : "else if";
            isFirst = false;

            string serviceType = service.ServiceType.ToDisplayString(s_fullyQualifiedFormat);
            sb.AppendLine($"{innerIndent}{ifPrefix} (typeof(T) == typeof({serviceType}))");
            sb.AppendLine($"{innerIndent}{{");

            switch (service.Lifetime)
            {
                case ServiceLifetime.Singleton:
                    sb.AppendLine($"{doubleIndent}return (T)(object){GetSingletonFieldName(service.ServiceType)}.Value;");
                    break;
                // Scoped/Transient will be implemented later.
            }

            sb.AppendLine($"{innerIndent}}}");
        }

        sb.AppendLine($"{innerIndent}throw new global::System.InvalidOperationException($\"Service of type {{typeof(T).FullName}} is not registered.\");");
        sb.AppendLine($"{indent}}}");
    }

    // --- Helper Methods for Naming ---

    private static string SanitizeTypeName(ITypeSymbol typeSymbol)
    {
        // This replaces characters that are invalid in an identifier with underscores.
        // e.g., "My.Generic<System.Int32>" becomes "My_Generic_System_Int32_"
        return typeSymbol.ToDisplayString().Replace(".", "_").Replace("<", "_").Replace(">", "_").Replace(",", "_");
    }

    private static string GetSingletonFieldName(ITypeSymbol serviceType)
    {
        return $"_singleton_{SanitizeTypeName(serviceType)}";
    }

    private static string GetFactoryMethodName(ITypeSymbol serviceType)
    {
        return $"Create_{SanitizeTypeName(serviceType)}";
    }
}