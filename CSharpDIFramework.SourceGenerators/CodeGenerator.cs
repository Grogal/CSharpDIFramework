using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;

using Microsoft.CodeAnalysis;

namespace CSharpDIFramework.SourceGenerators;

internal static class CodeGenerator
{
    private static readonly SymbolDisplayFormat s_fullyQualifiedFormat = SymbolDisplayFormat.FullyQualifiedFormat
                                                                                            .WithGlobalNamespaceStyle(
                                                                                                SymbolDisplayGlobalNamespaceStyle.Included
                                                                                            );

    public static string Generate(ContainerBlueprint blueprint)
    {
        var sb = new StringBuilder();

        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();

        if (!string.IsNullOrEmpty(blueprint.Namespace))
        {
            sb.AppendLine($"namespace {blueprint.Namespace!};");
            sb.AppendLine();
        }

        // Calculate base indentation level based on containing type declarations
        var indentLevel = 0;
        foreach (string? declaration in blueprint.ContainingTypeDeclarations)
        {
            sb.AppendLine($"{new string(' ', indentLevel * 4)}{declaration}");
            sb.AppendLine($"{new string(' ', indentLevel * 4)}{{");
            indentLevel++;
        }

        // Generate the container class with proper indentation
        var baseIndent = new string(' ', indentLevel * 4);
        sb.AppendLine($"{baseIndent}public partial class {blueprint.ContainerName} : global::System.IDisposable");
        sb.AppendLine($"{baseIndent}{{");
        sb.AppendLine($"{baseIndent}    private bool _isDisposed;");

        List<ResolvedService> singletons =
            blueprint.Services.Where(s => s.Lifetime == ServiceLifetime.Singleton).ToList();

        GenerateSingletonFields(sb, singletons, indentLevel + 1);
        GenerateConstructor(sb, blueprint.ContainerName, singletons, indentLevel + 1);
        GenerateSingletonFactories(sb, singletons, indentLevel + 1);
        GenerateResolveMethod(sb, blueprint, indentLevel + 1);
        GenerateCreateScopeMethod(sb, indentLevel + 1);
        GenerateDisposeMethod(sb, blueprint, indentLevel + 1);
        GenerateScopeClass(sb, blueprint, indentLevel + 1);

        sb.AppendLine($"{baseIndent}}}");

        // Close all containing type declarations
        for (int i = indentLevel - 1; i >= 0; i--)
        {
            sb.AppendLine($"{new string(' ', i * 4)}}}");
        }

        return sb.ToString();
    }

    public static string GenerateDummyFromName(string containerName, INamedTypeSymbol containerSymbol)
    {
        ImmutableArray<string> containingDecls = GraphBuilder.GetContainingTypeDeclarations(containerSymbol);
        string? ns = containerSymbol.ContainingNamespace.IsGlobalNamespace ? null : containerSymbol.ContainingNamespace.ToDisplayString();
        var dummyBlueprint = new ContainerBlueprint(containerSymbol, containerName, ns, ImmutableArray<ResolvedService>.Empty, null, containingDecls);
        return GenerateDummyContainer(dummyBlueprint);
    }

    public static string GenerateDummyContainer(ContainerBlueprint blueprint)
    {
        var sb = new StringBuilder();

        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("// DI Container generation failed due to errors.");
        sb.AppendLine("// This is a dummy implementation. Please see the Error List for details.");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();

        if (!string.IsNullOrEmpty(blueprint.Namespace))
        {
            sb.AppendLine($"namespace {blueprint.Namespace!};");
            sb.AppendLine();
        }

        foreach (string declaration in blueprint.ContainingTypeDeclarations)
        {
            sb.AppendLine(declaration);
            sb.AppendLine("{");
        }

        var indent = new string(' ', blueprint.ContainingTypeDeclarations.Length * 4);
        sb.AppendLine($"{indent}public partial class {blueprint.ContainerName}");
        sb.AppendLine($"{indent}{{");
        sb.AppendLine($"{indent}    private const string ErrorMessage = \"CSharpDIFramework container generation failed. See compile-time errors.\";");
        sb.AppendLine($"{indent}    public T Resolve<T>() => throw new global::System.InvalidOperationException(ErrorMessage);");
        sb.AppendLine($"{indent}}}");

        for (int i = blueprint.ContainingTypeDeclarations.Length - 1; i >= 0; i--)
        {
            sb.AppendLine($"{new string(' ', i * 4)}}}");
        }

        return sb.ToString();
    }

    private static void GenerateSingletonFields(StringBuilder sb, List<ResolvedService> singletons, int indentLevel)
    {
        var indent = new string(' ', indentLevel * 4);
        foreach (ResolvedService s in singletons)
        {
            string serviceType = s.ServiceTypeFullName;
            sb.AppendLine($"{indent}private readonly global::System.Lazy<{serviceType}> {GetSingletonFieldName(s.ServiceTypeFullName)};");
        }

        sb.AppendLine();
    }

    private static void GenerateConstructor(StringBuilder sb, string containerName, List<ResolvedService> singletons, int indentLevel)
    {
        var indent = new string(' ', indentLevel * 4);
        var innerIndent = new string(' ', (indentLevel + 1) * 4);

        sb.AppendLine($"{indent}public {containerName}()");
        sb.AppendLine($"{indent}{{");

        foreach (ResolvedService s in singletons)
        {
            string serviceType = s.ServiceTypeFullName;

            sb.AppendLine(
                $"{innerIndent}{GetSingletonFieldName(s.ServiceTypeFullName)} = new global::System.Lazy<{serviceType}>(() => {GetFactoryMethodName(s.ServiceTypeFullName)}());"
            );
        }

        sb.AppendLine($"{indent}}}");
        sb.AppendLine();
    }

    private static void GenerateSingletonFactories(StringBuilder sb, List<ResolvedService> singletons, int indentLevel)
    {
        var indent = new string(' ', indentLevel * 4);
        var innerIndent = new string(' ', (indentLevel + 1) * 4);

        foreach (ResolvedService service in singletons)
        {
            string serviceType = service.ServiceTypeFullName;

            sb.AppendLine($"{indent}private {serviceType} {GetFactoryMethodName(service.ServiceTypeFullName)}()");
            sb.AppendLine($"{indent}{{");

            sb.AppendLine($"{innerIndent}return {GenerateInstanceCreation(service, "this")};");

            sb.AppendLine($"{indent}}}");
            sb.AppendLine();
        }
    }

    private static void GenerateResolveMethod(StringBuilder sb, ContainerBlueprint blueprint, int indentLevel)
    {
        var indent = new string(' ', indentLevel * 4);
        var innerIndent = new string(' ', (indentLevel + 1) * 4);
        var doubleIndent = new string(' ', (indentLevel + 2) * 4);

        sb.AppendLine($"{indent}public T Resolve<T>()");
        sb.AppendLine($"{indent}{{");

        var isFirst = true;
        foreach (ResolvedService service in blueprint.Services)
        {
            string ifPrefix = isFirst ? "if" : "else if";
            isFirst = false;

            string serviceType = service.ServiceTypeFullName;
            sb.AppendLine($"{innerIndent}{ifPrefix} (typeof(T) == typeof({serviceType}))");
            sb.AppendLine($"{innerIndent}{{");

            switch (service.Lifetime)
            {
                case ServiceLifetime.Singleton:
                    sb.AppendLine($"{doubleIndent}return (T)(object){GetSingletonFieldName(service.ServiceTypeFullName)}.Value;");
                    break;
                case ServiceLifetime.Transient:
                    sb.AppendLine(
                        $"{doubleIndent}throw new global::System.InvalidOperationException($\"Service '{service.ServiceTypeFullName}' has a Transient lifetime and cannot be resolved from the root container. Please create and resolve from a scope.\");"
                    );
                    break;
                case ServiceLifetime.Scoped:
                    sb.AppendLine(
                        $"{doubleIndent}throw new global::System.InvalidOperationException($\"Service '{service.ServiceTypeFullName}' has a {service.Lifetime} lifetime and cannot be resolved from the root container. Please create and resolve from a scope.\");"
                    );
                    break;
            }

            sb.AppendLine($"{innerIndent}}}");
        }

        sb.AppendLine($"{innerIndent}throw new global::System.InvalidOperationException($\"Service of type {{typeof(T).FullName}} is not registered.\");");
        sb.AppendLine($"{indent}}}");
    }

    private static void GenerateCreateScopeMethod(StringBuilder sb, int indentLevel)
    {
        var indent = new string(' ', indentLevel * 4);
        sb.AppendLine($"{indent}public global::CSharpDIFramework.IContainerScope CreateScope()");
        sb.AppendLine($"{indent}{{");
        sb.AppendLine($"{indent}    return new Scope(this);");
        sb.AppendLine($"{indent}}}");
        sb.AppendLine();
    }

    private static void GenerateScopeClass(StringBuilder sb, ContainerBlueprint blueprint, int indentLevel)
    {
        var indent = new string(' ', indentLevel * 4);
        var innerIndent = new string(' ', (indentLevel + 1) * 4);
        var doubleIndent = new string(' ', (indentLevel + 2) * 4);
        var tripleIndent = new string(' ', (indentLevel + 3) * 4);

        sb.AppendLine($"{indent}private sealed partial class Scope : global::CSharpDIFramework.IContainerScope");
        sb.AppendLine($"{indent}{{");
        sb.AppendLine($"{innerIndent}private readonly {blueprint.ContainerName} _root;");
        sb.AppendLine($"{innerIndent}private readonly global::System.Collections.Generic.Dictionary<global::System.Type, object> _scopedInstances = new();");
        sb.AppendLine($"{innerIndent}private readonly global::System.Collections.Generic.List<global::System.IDisposable> _disposables = new();");
        sb.AppendLine($"{innerIndent}private bool _isDisposed;");
        sb.AppendLine();

        sb.AppendLine($"{innerIndent}public Scope({blueprint.ContainerName} root) {{ _root = root; }}");
        sb.AppendLine();

        sb.AppendLine($"{innerIndent}public T Resolve<T>()");
        sb.AppendLine($"{innerIndent}{{");
        sb.AppendLine($"{doubleIndent}if (_isDisposed) throw new global::System.ObjectDisposedException(nameof(Scope));");

        var isFirst = true;
        foreach (ResolvedService? service in blueprint.Services)
        {
            string ifPrefix = isFirst ? "if" : "else if";
            isFirst = false;

            string serviceType = service.ServiceTypeFullName;
            sb.AppendLine($"{doubleIndent}{ifPrefix} (typeof(T) == typeof({serviceType}))");
            sb.AppendLine($"{doubleIndent}{{");

            switch (service.Lifetime)
            {
                case ServiceLifetime.Singleton:
                    sb.AppendLine($"{tripleIndent}return _root.Resolve<T>();");
                    break;
                case ServiceLifetime.Scoped:
                    sb.AppendLine($"{tripleIndent}if (_scopedInstances.TryGetValue(typeof(T), out var scopedInstance)) return (T)scopedInstance;");
                    sb.AppendLine($"{tripleIndent}var newScopedInstance = {GenerateInstanceCreation(service, "this")};");
                    sb.AppendLine($"{tripleIndent}_scopedInstances.Add(typeof(T), newScopedInstance);");
                    sb.AppendLine($"{tripleIndent}return (T)(object)newScopedInstance;");
                    break;
                case ServiceLifetime.Transient:
                    sb.AppendLine($"{tripleIndent}var transientInstance = {GenerateInstanceCreation(service, "this")};");
                    sb.AppendLine(
                        $"{tripleIndent}if (transientInstance is global::System.IDisposable disposableTransient) {{ _disposables.Add(disposableTransient); }}"
                    );
                    sb.AppendLine($"{tripleIndent}return (T)(object)transientInstance;");
                    break;
            }

            sb.AppendLine($"{doubleIndent}}}");
        }

        sb.AppendLine($"{doubleIndent}throw new global::System.InvalidOperationException($\"Service of type {{typeof(T).FullName}} is not registered.\");");
        sb.AppendLine($"{innerIndent}}}");
        sb.AppendLine();

        // Scope Dispose()
        sb.AppendLine($"{innerIndent}public void Dispose()");
        sb.AppendLine($"{innerIndent}{{");
        sb.AppendLine($"{doubleIndent}if (_isDisposed) return;");
        sb.AppendLine($"{doubleIndent}_isDisposed = true;");
        sb.AppendLine($"{doubleIndent}foreach (var disposable in _disposables) {{ disposable.Dispose(); }}");
        sb.AppendLine($"{doubleIndent}foreach (var scopedInstance in _scopedInstances.Values)");
        sb.AppendLine($"{doubleIndent}{{");
        sb.AppendLine($"{doubleIndent}    if (scopedInstance is global::System.IDisposable disposableScoped) {{ disposableScoped.Dispose(); }}");
        sb.AppendLine($"{doubleIndent}}}");
        sb.AppendLine($"{innerIndent}}}");

        sb.AppendLine($"{indent}}}");
    }

    private static void GenerateDisposeMethod(StringBuilder sb, ContainerBlueprint blueprint, int indentLevel)
    {
        var indent = new string(' ', indentLevel * 4);
        var innerIndent = new string(' ', (indentLevel + 1) * 4);

        sb.AppendLine($"{indent}public void Dispose()");
        sb.AppendLine($"{indent}{{");
        sb.AppendLine($"{innerIndent}if (_isDisposed) return;");
        sb.AppendLine($"{innerIndent}_isDisposed = true;");
        sb.AppendLine();

        IEnumerable<ResolvedService> disposableSingletons =
            blueprint.Services.Where(s =>
                                         s.Lifetime == ServiceLifetime.Singleton && s.SourceRegistration.IsDisposable
            );
        foreach (ResolvedService? service in disposableSingletons)
        {
            string fieldName = GetSingletonFieldName(service.ServiceTypeFullName);

            sb.AppendLine($"{innerIndent}if ({fieldName}.IsValueCreated)");
            sb.AppendLine($"{innerIndent}{{");
            sb.AppendLine($"{innerIndent}    (({fieldName}.Value as global::System.IDisposable))?.Dispose();");
            sb.AppendLine($"{innerIndent}}}");
        }

        sb.AppendLine($"{indent}}}");
        sb.AppendLine();
    }

    // --- Helper Methods for Naming ---

    private static string SanitizeTypeName(string typeName)
    {
        // This replaces characters that are invalid in an identifier with underscores.
        // e.g., "global::My.Generic<System.Int32>" becomes "global__My_Generic_System_Int32_"
        return typeName.Replace("::", "__")
                       .Replace(".", "_")
                       .Replace("<", "_")
                       .Replace(">", "_")
                       .Replace(",", "_");
    }

    private static string GetSingletonFieldName(string serviceType)
    {
        return $"_singleton_{SanitizeTypeName(serviceType)}";
    }

    private static string GetFactoryMethodName(string serviceType)
    {
        return $"Create_{SanitizeTypeName(serviceType)}";
    }

    private static string GenerateInstanceCreation(ResolvedService service, string resolverContext)
    {
        string baseImplType = service.SourceRegistration.ImplementationType.ToDisplayString(s_fullyQualifiedFormat);
        IEnumerable<string> baseArgs =
            service.Dependencies.Select(d => $"{resolverContext}.Resolve<{d.ServiceTypeFullName}>()");
        var currentCall = $"new {baseImplType}({string.Join(", ", baseArgs)})";

        foreach (ResolvedDecorator? decorator in service.Decorators)
        {
            string decoratorTypeName = decorator.DecoratorType.ToDisplayString(s_fullyQualifiedFormat);
            var decoratorArgs = new List<string>();
            foreach (IParameterSymbol? param in decorator.SelectedConstructor.Parameters)
            {
                if (param.Type.ToDisplayString(s_fullyQualifiedFormat) == service.ServiceTypeFullName)
                {
                    decoratorArgs.Add(currentCall);
                }
                else
                {
                    decoratorArgs.Add($"{resolverContext}.Resolve<{param.Type.ToDisplayString(s_fullyQualifiedFormat)}>()");
                }
            }

            currentCall = $"new {decoratorTypeName}({string.Join(", ", decoratorArgs)})";
        }

        return currentCall;
    }
}