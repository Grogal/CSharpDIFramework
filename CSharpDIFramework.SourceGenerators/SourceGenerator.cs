using System;
using System.Linq;
using System.Text;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace CSharpDIFramework.SourceGenerators;

[Generator]
public class SourceGenerator : IIncrementalGenerator
{
    #region IIncrementalGenerator Implementation

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        IncrementalValuesProvider<(ServiceProviderDescription? Description, EquatableArray<DiagnosticInfo> Diagnostics)> parsedProvider =
            context.SyntaxProvider
                   .ForAttributeWithMetadataName(
                       Constants.RegisterContainerAttributeName,
                       (node, _) => node is ClassDeclarationSyntax,
                       (ctx, _) => BlueprintParser.Parse(ctx)
                   );

        context.RegisterSourceOutput(
            parsedProvider, (spc, source) =>
            {
                (ServiceProviderDescription? description, EquatableArray<DiagnosticInfo> diagnostics) = source;

                string debugFileName = description is not null
                    ? $"_DEBUG_{description.ContainerName}.g.cs"
                    : $"_DEBUG_OrphanedDiagnostics_{DateTime.Now:HH_mm_ss_fff}.g.cs";

                string debugContent = GenerateDebugOutput(description, diagnostics);

                spc.AddSource(debugFileName, debugContent);
            }
        );

        IncrementalValuesProvider<EquatableArray<DiagnosticInfo>> parsingDiagnostics =
            parsedProvider.Select((source, _) => source.Diagnostics);

        context.RegisterSourceOutput(
            parsingDiagnostics, (spc, diagnostics) =>
            {
                foreach (DiagnosticInfo? diagnostic in diagnostics)
                {
                    spc.ReportDiagnostic(diagnostic.CreateDiagnostic());
                }
            }
        );

        // Filter out null descriptions to get a clean provider of valid descriptions.
        IncrementalValuesProvider<ServiceProviderDescription> descriptionProvider =
            parsedProvider.Select((source, _) => source.Description)
                          .Where(desc => desc is not null)!;

        IncrementalValuesProvider<(ServiceProviderDescription, ContainerBlueprint?, EquatableArray<DiagnosticInfo>)> graphProvider =
            descriptionProvider.Select((description, _) =>
                {
                    var graphBuilder = new GraphBuilder(description);
                    (ContainerBlueprint? blueprint, EquatableArray<DiagnosticInfo> diagnostics) = graphBuilder.Build();
                    return (description, blueprint, diagnostics);
                }
            );

        context.RegisterSourceOutput(
            graphProvider, (spc, source) =>
            {
                (ServiceProviderDescription? description, ContainerBlueprint? blueprint, EquatableArray<DiagnosticInfo> diagnostics) = source;

                foreach (DiagnosticInfo diagnostic in diagnostics)
                {
                    spc.ReportDiagnostic(diagnostic.CreateDiagnostic());
                }

                if (description == null)
                {
                    return;
                }

                bool hasErrors = diagnostics.Any(d => d.Descriptor.DefaultSeverity == DiagnosticSeverity.Error);
                if (hasErrors)
                {
                    spc.AddSource($"{description.ContainerName}.g.cs", CodeGenerator.GenerateDummyContainer(description));
                }
                else if (blueprint != null)
                {
                    string sourceCode = CodeGenerator.Generate(blueprint);
                    spc.AddSource($"{blueprint.ContainerName}.g.cs", sourceCode);
                }
            }
        );
    }

    #endregion

    private static string GenerateDebugOutput(
        ServiceProviderDescription? description,
        EquatableArray<DiagnosticInfo> diagnostics)
    {
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("// This is a debug file generated by the CSharpDIFramework Source Generator.");
        sb.AppendLine($"// Generated at: {DateTime.Now}");
        sb.AppendLine();

        sb.AppendLine("// --- DIAGNOSTICS DUMP ---");
        sb.AppendLine($"// Diagnostics Count: {diagnostics.Count}");

        if (diagnostics.Count > 0)
        {
            var i = 0;
            foreach (DiagnosticInfo? diag in diagnostics)
            {
                sb.AppendLine($"// Diagnostic[{i}]:");
                sb.AppendLine($"//   Descriptor: {diag.Descriptor}");
                sb.AppendLine($"//   Location: {diag.Location?.FilePath ?? "No File"} ({diag.Location?.LineSpan.Start.Line ?? -1})");
                sb.AppendLine($"//   Message Args Count: {diag.MessageArgs.Count}");
                var j = 0;
                foreach (string? arg in diag.MessageArgs)
                {
                    sb.AppendLine($"//     Arg[{j++}]: \"{arg}\"");
                }

                i++;
            }
        }
        else
        {
            sb.AppendLine("// No diagnostics were found at this stage.");
        }

        sb.AppendLine();

        sb.AppendLine("// --- SERVICE PROVIDER DESCRIPTION DUMP ---");
        if (description is null)
        {
            sb.AppendLine("// Description is NULL.");
            sb.AppendLine("// This is expected if parsing failed and diagnostics were produced.");
        }
        else
        {
            sb.AppendLine($"// ContainerName: {description.ContainerName}");
            sb.AppendLine($"// Namespace: {description.Namespace ?? "global"}");
            sb.AppendLine($"// Containing Types Count: {description.ContainingTypeDeclarations.Count}");
            foreach (object? decl in description.ContainingTypeDeclarations)
            {
                sb.AppendLine($"//   - {decl}");
            }

            sb.AppendLine();
            sb.AppendLine($"// Registrations Count: {description.Registrations.Count}");
            var k = 0;
            foreach (ServiceRegistration? reg in description.Registrations)
            {
                sb.AppendLine($"// Registration[{k}]:");
                sb.AppendLine($"//   Service: {reg.ServiceTypeFullName}");
                sb.AppendLine($"//   Implementation: {reg.ImplementationType.FullName}");
                sb.AppendLine($"//   Lifetime: {reg.Lifetime}");
                sb.AppendLine($"//   IsDisposable: {reg.IsDisposable}");
                sb.AppendLine($"//   Decorators Count: {reg.Decorators.Count}");
                foreach (DecoratorInfo? dec in reg.Decorators)
                {
                    sb.AppendLine($"//     - Decorator: {dec.FullName}");
                }

                k++;
            }
        }

        return sb.ToString();
    }
}